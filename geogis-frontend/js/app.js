/* global proj4, ol */

// ƒêƒÉng k√Ω EPSG:3405 (VN-2000 / UTM zone 48N)
// L∆∞u √Ω: VN-2000 c√≥ nhi·ªÅu bi·∫øn th·ªÉ 7 tham s·ªë; n·∫øu c·∫ßn ƒë·ªô ch√≠nh x√°c cao so v·ªõi WGS84,
// c·∫≠p nh·∫≠t towgs84 ph√π h·ª£p khu v·ª±c H√† N·ªôi. ·ªû ƒë√¢y d√πng 0,0,0 ƒë·ªÉ hi·ªÉn th·ªã t∆∞∆°ng ƒë·ªëi.
proj4.defs(
  'EPSG:3405',
  '+proj=utm +zone=48 +ellps=WGS84 +units=m +no_defs +type=crs'
);
ol.proj.proj4.register(proj4);

const projectionVN2000 = ol.proj.get('EPSG:3405');

// Bi·∫øn cho ch·ª©c nƒÉng t√°ch th·ª≠a ƒë·∫•t
let isSplitMode = false;
let selectedPoints = [];
let selectedFeature = null;
let splitLayer = null;

// B·∫£ng m√†u theo MDSD2003 (ƒë·∫ßy ƒë·ªß theo th·ªëng k√™ data)
const defaultBorderColor = '#2c3e50'; // M√†u vi·ªÅn ƒë·ªìng nh·∫•t cho t·∫•t c·∫£
const mdsdColors = {
  // C√°c lo·∫°i ch√≠nh (s·ªë l∆∞·ª£ng l·ªõn) - m√†u t√¥ trong ƒë·ªìng nh·∫•t (alpha = 1)
  'LUC': [defaultBorderColor, 'rgba(241, 196, 15, 1)'], // ƒê·∫•t chuy√™n tr·ªìng l√∫a n∆∞·ªõc (2983 th·ª≠a) - v√†ng l√∫a
  'ONT': [defaultBorderColor, 'rgba(39, 174, 96, 1)'], // ƒê·∫•t ·ªü t·∫°i n√¥ng th√¥n (2402 th·ª≠a) - xanh l√° ƒë·∫≠m
  'BHK': [defaultBorderColor, 'rgba(46, 204, 113, 1)'], // ƒê·∫•t b·∫±ng tr·ªìng c√¢y h√†ng nƒÉm kh√°c (1348 th·ª≠a) - xanh non
  'SKC': [defaultBorderColor, 'rgba(230, 126, 34, 1)'], // ƒê·∫•t c∆° s·ªü s·∫£n xu·∫•t phi n√¥ng nghi·ªáp (962 th·ª≠a) - cam ƒë·∫•t
  'DTL': [defaultBorderColor, 'rgba(52, 152, 219, 1)'], // ƒê·∫•t th·ªßy l·ª£i (277 th·ª≠a) - xanh n∆∞·ªõc
  'DGT': [defaultBorderColor, 'rgba(149, 165, 166, 1)'], // ƒê·∫•t giao th√¥ng (142 th·ª≠a) - x√°m b√™ t√¥ng
  'LNQ': [defaultBorderColor, 'rgba(155, 89, 182, 1)'], // ƒê·∫•t tr·ªìng c√¢y ƒÉn qu·∫£ l√¢u nƒÉm (62 th·ª≠a) - t√≠m nh·∫°t
  'NTS': [defaultBorderColor, 'rgba(26, 188, 156, 1)'], // ƒê·∫•t nu√¥i tr·ªìng th·ªßy s·∫£n (38 th·ª≠a) - xanh ng·ªçc
  'TIN': [defaultBorderColor, 'rgba(192, 57, 43, 1)'], // ƒê·∫•t t√≠n ng∆∞·ª°ng (30 th·ª≠a) - ƒë·ªè g·∫°ch, m√†u t√¢m linh
  'NTD': [defaultBorderColor, 'rgba(127, 140, 141, 1)'], // Nghƒ©a trang d√¢n (17 th·ª≠a)
  'BCS': [defaultBorderColor, 'rgba(243, 156, 18, 1)'], // B·∫±ng c·∫•p s·ªü (15 th·ª≠a)
  'MNC': [defaultBorderColor, 'rgba(142, 68, 173, 1)'], // M·∫∑t n∆∞·ªõc (10 th·ª≠a)
  'DVH': [defaultBorderColor, 'rgba(211, 84, 0, 1)'], // D·ªãch v·ª• (6 th·ª≠a)
  'DYT': [defaultBorderColor, 'rgba(192, 57, 43, 1)'], // ƒê·∫•t y t·∫ø (5 th·ª≠a)
  'TSK': [defaultBorderColor, 'rgba(44, 62, 80, 1)'], // Th·ªßy s·∫£n (3 th·ª≠a)
  'TSC': [defaultBorderColor, 'rgba(127, 140, 141, 1)'], // Th·ªßy s·∫£n (3 th·ª≠a)
  'DNL': [defaultBorderColor, 'rgba(22, 160, 133, 1)'], // ƒê·∫•t n√¥ng l√¢m (3 th·ª≠a)
  'DGD': [defaultBorderColor, 'rgba(241, 196, 15, 1)'], // ƒê·∫•t gi√°o d·ª•c (3 th·ª≠a)
  'DCH': [defaultBorderColor, 'rgba(231, 76, 60, 1)'], // ƒê·∫•t chuy√™n (3 th·ª≠a)
  'SON': [defaultBorderColor, 'rgba(52, 152, 219, 1)'], // S√¥ng (1 th·ª≠a)
  'DRA': [defaultBorderColor, 'rgba(155, 89, 182, 1)'], // ƒê·∫•t rau (1 th·ª≠a)
  'default': [defaultBorderColor, 'rgba(189, 195, 199, 1)'] // M·∫∑c ƒë·ªãnh
};

function getStyleByMDSD(mdsd) {
  // T√¥ m√†u theo mdsd2003
  let [_, fillColor] = mdsdColors[mdsd] || mdsdColors.default; // B·ªè qua strokeColor t·ª´ mdsdColors
  return new ol.style.Style({
    fill: new ol.style.Fill({ color: fillColor }), // T√¥ m√†u b√™n trong
    stroke: new ol.style.Stroke({ color: defaultBorderColor, width: 2.5 }), // Vi·ªÅn ƒë·ªìng nh·∫•t m√†u ƒë·∫≠m
  });
}

function makeStyleByIndex(index) {
  // T·∫°m th·ªùi d√πng m√†u m·∫∑c ƒë·ªãnh, s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t khi load d·ªØ li·ªáu
  const [_, fillColor] = mdsdColors.default; // B·ªè qua strokeColor t·ª´ mdsdColors
  return new ol.style.Style({
    fill: new ol.style.Fill({ color: fillColor }),
    stroke: new ol.style.Stroke({ color: defaultBorderColor, width: 2.5 }), // Vi·ªÅn ƒë·ªìng nh·∫•t m√†u ƒë·∫≠m
  });
}

function createVectorLayer(url, style) {
  const format = new ol.format.GeoJSON();
  const source = new ol.source.Vector({
    loader: (extent, resolution, projection) => {
      fetch(url)
        .then((r) => r.json())
        .then((data) => {
          // √âp d·ªØ li·ªáu ƒë·∫ßu v√†o l√† EPSG:3405 b·∫•t k·ªÉ tr∆∞·ªùng crs b√™n trong
          const features = format.readFeatures(data, {
            dataProjection: 'EPSG:3405',
            featureProjection: 'EPSG:3405',
          });
          source.addFeatures(features);
        })
        .catch((e) => console.error('Load vector failed:', url, e));
    },
  });
  return new ol.layer.Vector({
    source,
    style: function(feature) {
      // T√¥ m√†u theo mdsd2003
      const mdsd = feature.get('mdsd2003') || feature.get('MDSD2003') || '';
      return getStyleByMDSD(mdsd);
    },
  });
}

// T·∫°o danh s√°ch l·ªõp dc1..dc27
const layers = [];
for (let i = 1; i <= 27; i += 1) {
  const style = makeStyleByIndex(i - 1);
  const layer = createVectorLayer(`data/dc${i}.geojson`, style);
  layer.set('name', `dc${i}`); // ƒê·∫∑t t√™n layer ƒë·ªÉ c√≥ th·ªÉ l·∫•y s·ªë t·ªù
  layers.push(layer);
}

// Map view: d√πng EPSG:3405 ƒë·ªÉ hi·ªÉn th·ªã ƒë√∫ng to·∫° ƒë·ªô VN-2000 (kh√¥ng c√≥ n·ªÅn OSM)
const map = new ol.Map({
  target: 'map',
  layers,
  view: new ol.View({
    projection: projectionVN2000,
    center: [568000, 2334800],
    zoom: 14,
  }),
});

map.addControl(new ol.control.ScaleLine());
map.addControl(new ol.control.ZoomSlider());

// Tooltip hover
const infoEl = document.createElement('div');
infoEl.style.position = 'absolute';
infoEl.style.pointerEvents = 'none';
infoEl.style.background = 'rgba(255,255,255,0.95)';
infoEl.style.border = '1px solid #ddd';
infoEl.style.borderRadius = '6px';
infoEl.style.padding = '6px 8px';
infoEl.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
infoEl.style.fontSize = '12px';
infoEl.style.display = 'none';
document.body.appendChild(infoEl);

// Hi·ªÉn th·ªã t·ªça ƒë·ªô ·ªü g√≥c d∆∞·ªõi ph·∫£i
const coordsEl = document.createElement('div');
coordsEl.id = 'coords';
coordsEl.style.cssText = `
  position: absolute;
  bottom: 10px;
  right: 10px;
  background: rgba(0,0,0,0.7);
  color: white;
  padding: 5px 10px;
  border-radius: 3px;
  font-family: monospace;
  font-size: 12px;
  z-index: 1000;
`;
document.body.appendChild(coordsEl);

function formatInfo(properties, layerName) {
  // L·∫•y s·ªë t·ªù t·ª´ t√™n layer (dc1 -> t·ªù 1, dc2 -> t·ªù 2, ...)
  const soTo = layerName ? layerName.replace('dc', '') : '';
  const soThua = properties.thua ?? properties.THUA ?? properties.id ?? '';
  const dienTich = properties.dien_tich ?? properties.Dien_tich ?? properties.area ?? '';
  const loaiDat = properties.loai_dat ?? properties.Loai_dat ?? '';
  const mdsd2003 = properties.mdsd2003 ?? properties.MDSD2003 ?? '';
  const chuSuDung = properties.chu_su_dung ?? properties.Chu_su_dung ?? properties.ten_chu ?? '';
  const diaChi = properties.dia_chi ?? properties.Dia_chi ?? '';
  const dienTichPhapLy = properties.dien_tich_phap_ly ?? properties.Dien_tich_phap_ly ?? '';
  const trangThaiPhapLy = properties.trang_thai_phap_ly ?? properties.Trang_thai_phap_ly ?? '';
  
  let info = '';
  if (soTo) info += `<div><b>S·ªë t·ªù b·∫£n ƒë·ªì:</b> ${soTo}</div>`;
  if (soThua) info += `<div><b>S·ªë th·ª≠a:</b> ${soThua}</div>`;
  if (dienTich) info += `<div><b>Di·ªán t√≠ch:</b> ${dienTich} m¬≤</div>`;
  if (loaiDat) info += `<div><b>Lo·∫°i ƒë·∫•t:</b> ${loaiDat}</div>`;
  if (mdsd2003) info += `<div><b>MDSD2003:</b> ${mdsd2003}</div>`;
  if (chuSuDung) info += `<div><b>Ch·ªß s·ª≠ d·ª•ng:</b> ${chuSuDung}</div>`;
  if (diaChi) info += `<div><b>ƒê·ªãa ch·ªâ:</b> ${diaChi}</div>`;
  
  // Hi·ªÉn th·ªã d·ªØ li·ªáu ph√°p l√Ω
  const hasLegalData = (dienTichPhapLy && dienTichPhapLy !== '' && dienTichPhapLy !== '0') || 
                      (trangThaiPhapLy && trangThaiPhapLy !== '');
  
  if (hasLegalData) {
    info += `<div class="legal-info"><b>üìã Th√¥ng tin ph√°p l√Ω:</b>`;
    if (dienTichPhapLy && dienTichPhapLy !== '' && dienTichPhapLy !== '0') {
      info += `<div><b>Di·ªán t√≠ch ph√°p l√Ω:</b> ${dienTichPhapLy} m¬≤</div>`;
    }
    if (trangThaiPhapLy && trangThaiPhapLy !== '') {
      info += `<div><b>Tr·∫°ng th√°i ph√°p l√Ω:</b> ${trangThaiPhapLy}</div>`;
    }
    info += `</div>`;
  } else {
    info += `<div style="margin-top: 10px; padding: 8px; background-color: #f8f9fa; border-left: 4px solid #6c757d; border-radius: 4px; color: #6c757d; font-size: 12px;">
      <b>üìã Th√¥ng tin ph√°p l√Ω:</b> Ch∆∞a c√≥ d·ªØ li·ªáu
    </div>`;
  }
  
  return info || '<div>Kh√¥ng c√≥ th√¥ng tin</div>';
}

map.on('pointermove', (evt) => {
  const pixel = evt.pixel;
  const coords = evt.coordinate;
  const lon = coords[0].toFixed(2);
  const lat = coords[1].toFixed(2);
  
  // Hi·ªÉn th·ªã t·ªça ƒë·ªô ·ªü g√≥c d∆∞·ªõi tr√°i
  coordsEl.textContent = `X: ${lon} | Y: ${lat}`;
  
  let shown = false;
  map.forEachFeatureAtPixel(pixel, (feature) => {
    const props = feature.getProperties();
    // T√¨m layer ch·ª©a feature n√†y ƒë·ªÉ l·∫•y t√™n layer
    let layerName = '';
    layers.forEach((layer) => {
      if (layer.getSource().getFeatures().includes(feature)) {
        layerName = layer.get('name') || layer.get('title') || '';
      }
    });
    infoEl.innerHTML = formatInfo(props, layerName);
    infoEl.style.left = `${pixel[0] + 12}px`;
    infoEl.style.top = `${pixel[1] + 12}px`;
    infoEl.style.display = 'block';
    shown = true;
    return true; // only first feature
  });
  if (!shown) infoEl.style.display = 'none';
});

// Fit extent sau khi t·∫•t c·∫£ l·ªõp n·∫°p xong
function whenSourcesReady(sources, callback) {
  let remaining = sources.length;
  sources.forEach((src) => {
    if (src.getState() === 'ready') {
      remaining -= 1;
      if (remaining === 0) callback();
    } else {
      const onChange = () => {
        if (src.getState() === 'ready') {
          src.un('change', onChange);
          remaining -= 1;
          if (remaining === 0) callback();
        }
      };
      src.on('change', onChange);
    }
  });
}

whenSourcesReady(
  layers.map((l) => l.getSource()),
  () => {
    const extents = layers
      .map((l) => l.getSource().getExtent())
      .filter((e) => e && !ol.extent.isEmpty(e));
    if (extents.length) {
      const union = extents.reduce((acc, cur) => (acc ? ol.extent.extend(acc, cur) : cur), null);
      map.getView().fit(union, { size: map.getSize(), padding: [20, 20, 20, 20], maxZoom: 18 });
    }
  }
);

// ===== CH·ª®C NƒÇNG T√ÅCH TH·ª¨A ƒê·∫§T =====

// T·∫°o layer ƒë·ªÉ hi·ªÉn th·ªã ƒëi·ªÉm ƒë√£ ch·ªçn v√† ƒë∆∞·ªùng t√°ch
function createSplitLayer() {
  const source = new ol.source.Vector();
  const layer = new ol.layer.Vector({
    source: source,
    style: function(feature) {
      const geometry = feature.getGeometry();
      if (geometry instanceof ol.geom.Point) {
        // Style cho ƒëi·ªÉm ƒë√£ ch·ªçn - l√†m to v√† n·ªïi b·∫≠t h∆°n
        const pointCoords = feature.getGeometry().getCoordinates();
        const pointIndex = selectedPoints.findIndex(p => 
          Math.abs(p[0] - pointCoords[0]) < 0.1 && Math.abs(p[1] - pointCoords[1]) < 0.1
        );
        
        return new ol.style.Style({
          image: new ol.style.Circle({
            radius: 12,
            fill: new ol.style.Fill({ color: '#e74c3c' }),
            stroke: new ol.style.Stroke({ color: '#fff', width: 3 })
          }),
          text: new ol.style.Text({
            text: (pointIndex + 1).toString(),
            font: 'bold 14px Arial',
            fill: new ol.style.Fill({ color: '#fff' }),
            stroke: new ol.style.Stroke({ color: '#000', width: 2 }),
            offsetY: -25
          })
        });
      } else if (geometry instanceof ol.geom.LineString) {
        // Style cho ƒë∆∞·ªùng t√°ch
        return new ol.style.Style({
          stroke: new ol.style.Stroke({ 
            color: '#e74c3c', 
            width: 4,
            lineDash: [8, 8]
          })
        });
      }
    }
  });
  return layer;
}

// T√¨m ƒëi·ªÉm g·∫ßn nh·∫•t tr√™n ƒë∆∞·ªùng vi·ªÅn c·ªßa feature
function findNearestPointOnBoundary(feature, clickCoordinate) {
  const geometry = feature.getGeometry();
  if (!geometry) return null;
  
  const coordinates = geometry.getCoordinates()[0]; // L·∫•y coordinates c·ªßa polygon
  let nearestPoint = null;
  let minDistance = Infinity;
  
  // T√¨m ƒëi·ªÉm g·∫ßn nh·∫•t tr√™n ƒë∆∞·ªùng vi·ªÅn
  for (let i = 0; i < coordinates.length - 1; i++) {
    const segmentStart = coordinates[i];
    const segmentEnd = coordinates[i + 1];
    
    // T√≠nh ƒëi·ªÉm g·∫ßn nh·∫•t tr√™n ƒëo·∫°n th·∫≥ng n√†y
    const segment = new ol.geom.LineString([segmentStart, segmentEnd]);
    const closestPoint = segment.getClosestPoint(clickCoordinate);
    
    const distance = ol.coordinate.distance(clickCoordinate, closestPoint);
    if (distance < minDistance) {
      minDistance = distance;
      nearestPoint = closestPoint;
    }
  }
  
  console.log('T√¨m th·∫•y ƒëi·ªÉm g·∫ßn nh·∫•t:', nearestPoint, 'kho·∫£ng c√°ch:', minDistance);
  return nearestPoint;
}

// T√°ch th·ª≠a ƒë·∫•t
function splitParcel(feature, point1, point2) {
  const geometry = feature.getGeometry();
  if (!geometry || !(geometry instanceof ol.geom.Polygon)) {
    console.error('Kh√¥ng th·ªÉ t√°ch th·ª≠a: geometry kh√¥ng h·ª£p l·ªá');
    return;
  }
  
  const coordinates = geometry.getCoordinates()[0];
  console.log('T·ªça ƒë·ªô polygon g·ªëc:', coordinates.length, 'ƒëi·ªÉm');
  
  // T√¨m v·ªã tr√≠ g·∫ßn nh·∫•t c·ªßa 2 ƒëi·ªÉm tr√™n ƒë∆∞·ªùng vi·ªÅn
  let index1 = -1, index2 = -1;
  let minDist1 = Infinity, minDist2 = Infinity;
  
  // T√¨m ƒëi·ªÉm g·∫ßn nh·∫•t tr√™n t·ª´ng c·∫°nh
  for (let i = 0; i < coordinates.length - 1; i++) {
    const segmentStart = coordinates[i];
    const segmentEnd = coordinates[i + 1];
    
    // T√≠nh kho·∫£ng c√°ch t·ª´ point1 ƒë·∫øn c·∫°nh n√†y
    const segment1 = new ol.geom.LineString([segmentStart, segmentEnd]);
    const closestPoint1 = segment1.getClosestPoint(point1);
    const dist1 = ol.coordinate.distance(point1, closestPoint1);
    
    if (dist1 < minDist1) {
      minDist1 = dist1;
      index1 = i;
    }
    
    // T√≠nh kho·∫£ng c√°ch t·ª´ point2 ƒë·∫øn c·∫°nh n√†y
    const closestPoint2 = segment1.getClosestPoint(point2);
    const dist2 = ol.coordinate.distance(point2, closestPoint2);
    
    if (dist2 < minDist2) {
      minDist2 = dist2;
      index2 = i;
    }
  }
  
  console.log('V·ªã tr√≠ ƒëi·ªÉm 1:', index1, 'kho·∫£ng c√°ch:', minDist1);
  console.log('V·ªã tr√≠ ƒëi·ªÉm 2:', index2, 'kho·∫£ng c√°ch:', minDist2);
  
  if (index1 === -1 || index2 === -1) {
    console.error('Kh√¥ng t√¨m th·∫•y v·ªã tr√≠ ƒëi·ªÉm tr√™n ƒë∆∞·ªùng vi·ªÅn');
    return;
  }
  
  // ƒê·∫£m b·∫£o index1 < index2
  if (index1 > index2) {
    [index1, index2] = [index2, index1];
    [point1, point2] = [point2, point1];
  }
  
  console.log('Sau s·∫Øp x·∫øp - index1:', index1, 'index2:', index2);
  
  // T·∫°o 2 polygon m·ªõi
  const coords1 = [point1];
  const coords2 = [point2];
  
  // Polygon 1: t·ª´ point1, qua c√°c ƒëi·ªÉm t·ª´ index1 ƒë·∫øn index2, v·ªÅ point1
  for (let i = index1; i <= index2; i++) {
    coords1.push(coordinates[i]);
  }
  coords1.push(point1); // ƒê√≥ng polygon
  
  // Polygon 2: t·ª´ point2, qua c√°c ƒëi·ªÉm t·ª´ index2 ƒë·∫øn cu·ªëi, t·ª´ ƒë·∫ßu ƒë·∫øn index1, v·ªÅ point2
  for (let i = index2; i < coordinates.length - 1; i++) {
    coords2.push(coordinates[i]);
  }
  for (let i = 0; i <= index1; i++) {
    coords2.push(coordinates[i]);
  }
  coords2.push(point2); // ƒê√≥ng polygon
  
  console.log('Polygon 1 c√≥', coords1.length, 'ƒëi·ªÉm');
  console.log('Polygon 2 c√≥', coords2.length, 'ƒëi·ªÉm');
  
  // T·∫°o 2 feature m·ªõi
  const newFeature1 = new ol.Feature({
    geometry: new ol.geom.Polygon([coords1]),
    properties: feature.getProperties()
  });
  
  const newFeature2 = new ol.Feature({
    geometry: new ol.geom.Polygon([coords2]),
    properties: feature.getProperties()
  });
  
  // Th√™m v√†o layer g·ªëc v√† x√≥a feature c≈©
  const source = feature.get('source');
  if (source) {
    source.addFeatures([newFeature1, newFeature2]);
    source.removeFeature(feature);
  }
  
  return [newFeature1, newFeature2];
}

// X·ª≠ l√Ω click khi ·ªü ch·∫ø ƒë·ªô t√°ch th·ª≠a
function handleSplitClick(evt) {
  if (!isSplitMode) return;
  
  console.log('Click trong ch·∫ø ƒë·ªô t√°ch th·ª≠a');
  const coordinate = evt.coordinate;
  let clickedFeature = null;
  
  // T√¨m feature ƒë∆∞·ª£c click
  map.forEachFeatureAtPixel(evt.pixel, (feature) => {
    if (feature.getGeometry() instanceof ol.geom.Polygon) {
      clickedFeature = feature;
      return true;
    }
  });
  
  if (!clickedFeature) {
    alert('Vui l√≤ng click v√†o th·ª≠a ƒë·∫•t c·∫ßn t√°ch');
    return;
  }
  
  console.log('ƒê√£ click v√†o feature:', clickedFeature);
  
  // N·∫øu ch∆∞a ch·ªçn feature, ch·ªçn feature n√†y
  if (!selectedFeature) {
    selectedFeature = clickedFeature;
    console.log('Ch·ªçn feature ƒë·ªÉ t√°ch:', selectedFeature);
    // Highlight feature ƒë∆∞·ª£c ch·ªçn
    selectedFeature.setStyle(new ol.style.Style({
      fill: new ol.style.Fill({ color: 'rgba(255, 255, 0, 0.3)' }),
      stroke: new ol.style.Stroke({ color: '#ff0000', width: 3 })
    }));
    alert('ƒê√£ ch·ªçn th·ª≠a ƒë·∫•t. B√¢y gi·ªù click 2 ƒëi·ªÉm tr√™n ƒë∆∞·ªùng vi·ªÅn ƒë·ªÉ t√°ch.');
    return;
  }
  
  // Ch·ªâ cho ph√©p click v√†o feature ƒë√£ ch·ªçn
  if (clickedFeature !== selectedFeature) {
    alert('Vui l√≤ng click v√†o th·ª≠a ƒë·∫•t ƒë√£ ch·ªçn (c√≥ vi·ªÅn ƒë·ªè)');
    return;
  }
  
  // T√¨m ƒëi·ªÉm g·∫ßn nh·∫•t tr√™n ƒë∆∞·ªùng vi·ªÅn
  const nearestPoint = findNearestPointOnBoundary(selectedFeature, coordinate);
  if (!nearestPoint) {
    alert('Kh√¥ng th·ªÉ x√°c ƒë·ªãnh ƒëi·ªÉm tr√™n ƒë∆∞·ªùng vi·ªÅn');
    return;
  }
  
  console.log('ƒêi·ªÉm ƒë∆∞·ª£c ch·ªçn:', nearestPoint);
  
  // Th√™m ƒëi·ªÉm v√†o danh s√°ch
  selectedPoints.push(nearestPoint);
  
  // C·∫≠p nh·∫≠t UI
  const pointStatus = document.getElementById(`point${selectedPoints.length}-status`);
  if (pointStatus) {
    pointStatus.textContent = `ƒê√£ ch·ªçn (${nearestPoint[0].toFixed(1)}, ${nearestPoint[1].toFixed(1)})`;
  }
  
  // Th√™m ƒëi·ªÉm v√†o split layer
  const pointFeature = new ol.Feature({
    geometry: new ol.geom.Point(nearestPoint)
  });
  splitLayer.getSource().addFeature(pointFeature);
  
  // V·∫Ω ƒë∆∞·ªùng n·ªëi gi·ªØa c√°c ƒëi·ªÉm ƒë√£ ch·ªçn
  if (selectedPoints.length >= 1) {
    // X√≥a ƒë∆∞·ªùng n·ªëi c≈©
    const source = splitLayer.getSource();
    const features = source.getFeatures();
    features.forEach(feature => {
      if (feature.getGeometry() instanceof ol.geom.LineString) {
        source.removeFeature(feature);
      }
    });
    
    // V·∫Ω ƒë∆∞·ªùng n·ªëi m·ªõi
    if (selectedPoints.length === 1) {
      // V·∫Ω ƒë∆∞·ªùng t·ª´ ƒëi·ªÉm 1 ƒë·∫øn ƒëi·ªÉm hi·ªán t·∫°i
      const lineFeature = new ol.Feature({
        geometry: new ol.geom.LineString([selectedPoints[0], nearestPoint])
      });
      source.addFeature(lineFeature);
    } else if (selectedPoints.length === 2) {
      // V·∫Ω ƒë∆∞·ªùng n·ªëi 2 ƒëi·ªÉm
      const lineFeature = new ol.Feature({
        geometry: new ol.geom.LineString([selectedPoints[0], selectedPoints[1]])
      });
      source.addFeature(lineFeature);
    }
  }
  
  console.log('ƒê√£ th√™m ƒëi·ªÉm v√†o split layer. T·ªïng s·ªë ƒëi·ªÉm:', selectedPoints.length);
  
  // N·∫øu ƒë√£ ch·ªçn ƒë·ªß 2 ƒëi·ªÉm, hi·ªÉn th·ªã preview v√† x√°c nh·∫≠n
  if (selectedPoints.length === 2) {
    // Hi·ªÉn th·ªã preview ƒë∆∞·ªùng t√°ch
    const previewLine = new ol.Feature({
      geometry: new ol.geom.LineString([selectedPoints[0], selectedPoints[1]])
    });
    splitLayer.getSource().addFeature(previewLine);
    
    // X√°c nh·∫≠n tr∆∞·ªõc khi t√°ch
    const confirm = confirm(`ƒê√£ ch·ªçn 2 ƒëi·ªÉm ƒë·ªÉ t√°ch th·ª≠a ƒë·∫•t.\n\nƒêi·ªÉm 1: (${selectedPoints[0][0].toFixed(1)}, ${selectedPoints[0][1].toFixed(1)})\nƒêi·ªÉm 2: (${selectedPoints[1][0].toFixed(1)}, ${selectedPoints[1][1].toFixed(1)})\n\nB·∫°n c√≥ mu·ªën th·ª±c hi·ªán t√°ch th·ª≠a ƒë·∫•t?`);
    
    if (confirm) {
      try {
        const newFeatures = splitParcel(selectedFeature, selectedPoints[0], selectedPoints[1]);
        if (newFeatures) {
          alert('T√°ch th·ª≠a ƒë·∫•t th√†nh c√¥ng!');
          resetSplitMode();
        }
      } catch (error) {
        console.error('L·ªói khi t√°ch th·ª≠a:', error);
        alert('C√≥ l·ªói x·∫£y ra khi t√°ch th·ª≠a ƒë·∫•t');
      }
    } else {
      // H·ªßy t√°ch, x√≥a ƒëi·ªÉm cu·ªëi v√† ƒë∆∞·ªùng preview
      selectedPoints.pop();
      splitLayer.getSource().removeFeature(previewLine);
      document.getElementById('point2-status').textContent = 'Ch∆∞a ch·ªçn';
      alert('ƒê√£ h·ªßy t√°ch th·ª≠a ƒë·∫•t. B·∫°n c√≥ th·ªÉ ch·ªçn l·∫°i ƒëi·ªÉm th·ª© 2.');
    }
  } else {
    alert(`ƒê√£ ch·ªçn ƒëi·ªÉm ${selectedPoints.length}/2. Click th√™m 1 ƒëi·ªÉm n·ªØa tr√™n ƒë∆∞·ªùng vi·ªÅn.`);
  }
}

// Reset ch·∫ø ƒë·ªô t√°ch
function resetSplitMode() {
  isSplitMode = false;
  selectedPoints = [];
  selectedFeature = null;
  
  // Reset UI
  document.getElementById('split-parcel-btn').style.display = 'inline-block';
  document.getElementById('cancel-split-btn').style.display = 'none';
  document.getElementById('split-instructions').style.display = 'none';
  document.getElementById('point1-status').textContent = 'Ch∆∞a ch·ªçn';
  document.getElementById('point2-status').textContent = 'Ch∆∞a ch·ªçn';
  
  // X√≥a split layer
  if (splitLayer) {
    splitLayer.getSource().clear();
  }
  
  // Reset style c·ªßa feature ƒë∆∞·ª£c ch·ªçn
  if (selectedFeature) {
    selectedFeature.setStyle(null);
  }
}

// Event listeners cho c√°c n√∫t
document.addEventListener('DOMContentLoaded', function() {
  const splitBtn = document.getElementById('split-parcel-btn');
  const cancelBtn = document.getElementById('cancel-split-btn');
  
  splitBtn.addEventListener('click', function() {
    isSplitMode = true;
    splitBtn.style.display = 'none';
    cancelBtn.style.display = 'inline-block';
    document.getElementById('split-instructions').style.display = 'block';
    
    // T·∫°o split layer n·∫øu ch∆∞a c√≥
    if (!splitLayer) {
      splitLayer = createSplitLayer();
      map.addLayer(splitLayer);
    }
  });
  
  cancelBtn.addEventListener('click', function() {
    resetSplitMode();
  });
});

// Th√™m event listener cho map click
map.on('click', handleSplitClick);
